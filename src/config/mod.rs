//! This is the module Awesome.toml
use crate::prelude::*;
use crate::VERSION;
use serde_derive::Deserialize;
use std::fs;
use std::path::Path;

mod runner;

// --- re-exports
pub use runner::*; // Wide for now.

// --- Consts
const AWESOME_TMPL: &str = include_str!("../../tmpl/Awesome.toml");
const AWESOME_FILE_NAME: &str = "Awesome.toml";

// --- Config Types
#[derive(Debug, Deserialize)]
pub struct Config {
	pub cli_version: Option<String>,
	pub dev: Option<Dev>,
}

#[derive(Debug, Deserialize)]
pub struct Dev {
	pub runners: Option<Vec<Runner>>,
}

// --- Awesome.toml generator / parser

pub fn ensure_awesome_toml(root_dir: &Path) -> Result<Config> {
	// --- Create if not present.
	let awesome_file = root_dir.join(AWESOME_FILE_NAME);
	if !awesome_file.is_file() {
		create_awesome_toml(&awesome_file)?;
	}

	// --- Load and validate.
	let toml_str = fs::read_to_string(&awesome_file)?;
	parse_awesome_toml(&toml_str)
}

fn create_awesome_toml(awesome_file: &Path) -> Result<()> {
	let mut content = String::new();
	content.push_str(&format!(
		r#"# Generated by 'awesome-app' command line.
awesome_app_version = "{VERSION}"

"#
	));
	content.push_str(AWESOME_TMPL);

	fs::write(awesome_file, &content)?;

	Ok(())
}

fn parse_awesome_toml(toml_str: &str) -> Result<Config> {
	let config = toml::from_str::<Config>(toml_str).map_err(Error::FailParsingConfig)?;

	let _number_of_dev_runners = config
		.dev
		.as_ref()
		.and_then(|d| d.runners.as_ref())
		.map(|rs| rs.len())
		.unwrap_or_default();

	Ok(config)
}

// region:    --- Tests
#[cfg(test)]
#[path = "../_tests/tests_config.rs"]
mod tests;
// endregion: --- Tests
